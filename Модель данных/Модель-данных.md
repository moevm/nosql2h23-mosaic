# Нереляционная модель
## Графическое представление модели
## Описание назначений
### Узлы:
1. User - предназначен для хранения каждого пользователя. Узел имеет **метки**:
   - *eMail: String* - хранит адресс электронной почты.
   - *password: String* - хранит пароль пользователя.
3. Mosaic - предназначен для хранения мозаик. Имеет **метку** *cfg: String*, которая является ссылкой на конфигурационный файл мозайки, хранящий всю информацию и ней.
### Отношения:
1. Selected - взаимосвязь, предназначена для описания мозаик, которые видны пользователю - то есть те, которые он выбрал для воспроизведения. Данное отношение имеет атрибуты:
   - *dateCreated: String* - для хранения момента создания мозаики;
   - *dateEdited: String* - для хранения момента последнего редактирования;
   - *progress: Integer* - для отслеживания прогресса воспроизведения мозаик.
### Оценка удельного объема информации, хранимой в модели
Neo4j для хранения данных использует фиксированное количество памяти для хранения каждой сущности:
- 15 байт для хранения каждого узла;
- 34 байта для хранения каждого отношения;
- 41 байт для хранения атрибутов узлов и отношений;
- 128 байт для хранения строчных атрибутов.

Следовательно, для хранения: 
- узла *User* с его атрибутами требуется - 15 + 128 \* 2 = 271 байт;
- узла *Mosaic* с его атрибутами требуется - 15 + 128 = 143 байта;
- отношения *Selected* с его атрибутами требуется - 34 + 41 + 128 \* 2 = 331 байт.  

Если принять, что на каждого пользователя приходится по 5 уникальных мозаик, и в системе находится 50 пользователей, то в получившейся базе данных будет:  
- 50 узлов *User*
- 250 узлов *Mosaic*
- 250 отношений *Selected*

Общий объём получившийся базы данных будет равен: 50 \* 271 + 250 \* 143 + 250 \* 331 = 128,9 мегабайт.
### Избыточность модели
Для того, чтобы Neo4j могла использовать смещение, данные хранятся в фиксированном объёме памяти - для любого строкового атрибута выделяется 128 байт, несмотря на его размер. Следовательно, в общем случае фактический объём модели сильно больше "чистого" объёма.
### Направление роста модели
Исходя из предыдущего пункта, можно сделать вывод, что модель обладает линейным ростом, так как при создании узла или отношения выделяется константное количество памяти.
### Запросы к модели
#### Создание узла User
> CREATE (user:User { eMail : 'example@etu.ru', password : 'RushE123' })
#### Создание узла Mosaic
> CREATE (mosaic:Mosaic { cfg : 'mosaics/mosaic1.mosaic'})
#### Создание отношения
> MATCH (m:mosaic {cfg: 'mosaics/mosaic1.mosaic'}), (u:user {eMail: 'example@etu.ru'}) MERGE (u)-[:Selected {dateCreated: '23.10.2023', dateEdited: '24.10.2023', progress: 47}]->(m)
#### Поиск всех активных мозаик пользователя
> MATCH (u:user {eMail: 'example@etu.ru'})-[:Selected]->(m:mosaic) RETURN m
# Реляционная модель
## Графическое представление модели
### Оценка удельного объема информации, хранимой в модели
1. Таблица User:
    - id - INT -> 4 байта
    - eMail - VARCHAR(255) -> 255 байт
    - password - VARCHAR(255) -> 255 байт
2. Таблица Mosaic:
   - id - INT -> 4 байта
   - path - VARCHAR(255) -> 255 байт
3. Таблица Map:
   - userId - INT -> 4 байта
   - mosaicId - INT -> 4 байта
   - dateCreated - VARCHAR(255) -> 255 байт
   - dateEdited - VARCHAR(255) -> 255 байт
   - progress - INT -> 4 байта

Возьмём те же показатели, что и при оценке объема данных в нереляционной модели (50 пользователей, 250 уникальных мозаек):  
V = 50 \* (4 + 255 + 255) + 250 \* (4 + 255) + 250 \* (4 + 4 + 255 + 255) = 214,7 мегабайт.
### Запросы к модели
#### Создание узла User
> INSERT INTO Users VALUES ('example@etu.ru', 'RushE123')
#### Создание узла Mosaic
> INSERT INTO Mosaics VALUES ('mosaics/mosaic1.mosaic')
#### Создание связи
> SELECT Users.id, Mosaics.id FROM Users, Mosaics WHERE Users.eMail IN("example@etu.ru”) AND Mosaics.path = 'mosaics/mosaic1.mosaic' getting id_1, id_2 and create query: INSERT INTO Map Values (id_1, id_2, '23.10.2023', '24.10.2023', 47)
#### Поиск всех активных мозаик пользователя
> SELECT id FROM Users WHERE eMail IN("example@etu.ru”) getting user_id
> SELECT mosaicId FROM Map WHERE userId == user_id getting mosaic_ids
> SELECT path FROM Mosaics WHERE id IN mosaic_ids
  
Количество запросов: 3.  

# Сравнение моделей
- В реляционной реализации модели данных пришлось бы создавать дополнительные таблицы для связей, что увеличивает суммарное количество создаваемых таблиц.
- В реляционной версии данны, скорее всего,е занимают больше мест, но практического подтверждения этому нет) Вывод сделан исходя из примерного подсчёта.
- Количество запросов, необходимых для выполнения юзкейсов реляционнойQL модели больше.
